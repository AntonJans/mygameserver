#!/usr/bin/python3

import logging
import argparse
import asyncio
import asyncio.subprocess
import psycopg2
import base64
import flag

@asyncio.coroutine
def run_checker(service, team, tick, checker, loglevel, dbconnection):
    logger = logging.getLogger("service%02d-team%03d-tick%03d" % (service, team, tick))
    create = asyncio.create_subprocess_exec("./checkerslave",
                                            "--service", str(service),
                                            "--team", str(team),
                                            "--tick", str(tick),
                                            "--loglevel", loglevel,
                                            "--ip", "10.66.%d.2" % team,
                                            checker,
                                            stdout=asyncio.subprocess.PIPE,
                                            stderr=asyncio.subprocess.PIPE,
                                            stdin=asyncio.subprocess.PIPE)

    process = yield from create
    while True:
        line = yield from process.stdout.readline()
        if process.returncode is not None:
            print(repr(process.returncode))

        if line == b'':
            err = yield from process.stderr.read()
            print(err.decode("utf-8"))
            return

        logger.debug(repr(line))
        line = line.decode('us-ascii').split()

        if "FLAG" == line[0]:
            tick = int(line[1])
            payload = None
            if len(line) > 2:
                payload = codecs.decode(line[2], 'hex')
            newflag = flag.generate(team=team, service=service, payload=payload)
            process.stdin.write(newflag.encode('us-ascii'))
            process.stdin.write(b"\n")

        elif "STORE" == line[0]:
            try:
                with dbconnection:
                    with dbconnection.cursor() as cursor:
                        ident = line[1]
                        data = psycopg2.Binary(base64.b64decode(line[2]))

                        cursor.execute("""INSERT INTO checkercache
                                             (service_id,team_id,identifier,data)
                                          VALUES
                                             (%s, %s, %s, %s) """,
                                       (service, team, ident, data))

                        process.stdin.write(b"OK\n")
            except Exception as e:
                process.stdin.write(b"FAIL\n")
                logger.warn("Database store failed with %s", repr(e))

        elif "RETRIEVE" == line[0]:
            try:
                with dbconnection:
                    with dbconnection.cursor() as cursor:
                        ident = line[1]
                        cursor.execute("""SELECT data FROM checkercache
                                          WHERE team_id = %s
                                            AND service_id = %s
                                            AND identifier = %s""",
                                       (team, service, ident))
                        data = cursor.fetchone()
                        if data != None:
                            data, = data
                            data = base64.b64encode(data)
                            process.stdin.write(data)
                        process.stdin.write(b"\n")

            except Exception as e:
                process.stdin.write(b"\n")
                logger.warn("Database get failed with %s", repr(e))

        elif line[0] in ["OK", "TIMEOUT", "NOTWORKING", "NOTFOUND"]:
            job_finished(line[0])
            break

    yield from process.wait()
    print("DONE (%d,%d,%d)" % (service, team, tick))


def get_fresh_jobs(args, gamedb, cachedb):
    loop = asyncio.get_event_loop()
    loop.call_later(args.refresh, get_fresh_jobs, args, gamedb, cachedb)

    current_tasks = len(asyncio.Task.all_tasks(loop))
    new_tasks = args.maxtasks - current_tasks
    logging.info("Currently running %d tasks, starting up to %d fresh ones",
                 current_tasks, new_tasks)

    for i in range(0, new_tasks):
        loop.create_task(run_checker(args.service, i, 12, args.checker,
                                     args.loglevel, db))


def job_finished(state):
    print(state)


def main():
    logging.basicConfig()
    parser = argparse.ArgumentParser(description="CTF checker runner")
    parser.add_argument('checker', type=str,
                        help="module:classname of checker")
    parser.add_argument('--verbose', action="store_true")
    parser.add_argument('--service', type=int, required=True)
    parser.add_argument('--maxtasks', type=int, required=True)
    parser.add_argument('--refresh', type=float, required=True,
                        help="Duration to sleep before rechecking for new tasks")
    parser.add_argument('--gamedb', type=str,
                        default="dbname=faustctf user=submission")
    parser.add_argument('--cachedb', type=str,
                        default="dbname=faustctf user=submission")
    parser.add_argument('-v', '--loglevel', default='WARNING', type=str,
                        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        help='Loglevel')

    args = parser.parse_args()

    numeric_level = getattr(logging, args.loglevel.upper())
    logging.getLogger().setLevel(numeric_level)

    logging.debug("connecting to database")
    cachedb = psycopg2.connect(args.cachedb)
    gamedb = psycopg2.connect(args.cachedb)

    loop = asyncio.get_event_loop()
    loop.call_soon(get_fresh_jobs, args, gamedb, cachedb)
    loop.run_forever()

if __name__ == '__main__':
    main()
